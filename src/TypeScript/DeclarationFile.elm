module TypeScript.DeclarationFile exposing (PortFunction, ProgramDeclaration, TSDocs, TypeString, write)

import String.Interpolate exposing (interpolate)
import TypeScript.Writer as Writer exposing (Writer)


{-| A valid TypeScript type, encoded in a string.
-}
type alias TypeString =
    String


{-| A jsdoc style doc comment.
-}
type alias TSDocs =
    String


{-| A "send" or "subscribe" function to interface with ports from TypeScript.
-}
type alias PortFunction =
    { name : String, body : TypeString }


{-| All of the formatted strings needed to build a declaration file. While
these parts of the declaration file are internally formatted, contextual
formatting such as indentation and ending semi-colons has not been applied.
-}
type alias ProgramDeclaration =
    { moduleParents : List String
    , moduleName : String
    , docs : Maybe TSDocs
    , flags : Maybe TypeString
    , ports : List PortFunction
    }


{-| Construct the full declaration file and output the resulting string.
-}
write : List ProgramDeclaration -> String
write declarations =
    declarations |> writeDeclarationFile |> Writer.toString


{-| Writer to construct the full declaration file.
-}
writeDeclarationFile : List ProgramDeclaration -> Writer
writeDeclarationFile declarations =
    Writer.file
        [ Writer.autoGeneratedFileWarning
        , Writer.newline
        , Writer.declareModule "\"*.elm\""
            [ Writer.namespace { docs = Nothing, export = True, name = "Elm" }
                (List.map writeProgramDeclaration declarations)
            ]
        ]


{-| Writer to create an Elm program namespace containing types for the ports
interface and init function.
-}
writeProgramDeclaration : ProgramDeclaration -> Writer
writeProgramDeclaration { moduleParents, moduleName, docs, flags, ports } =
    writeNestedParentNamespaces moduleParents
        [ Writer.namespace { docs = docs, export = False, name = moduleName }
            [ Writer.interface { export = True, name = "App" }
                [ Writer.ports ports ]
            , Writer.initFn { moduleName = moduleName, flags = flags }
            ]
        ]


{-| If the program module is nested in the module structure (probably a rare
edge case), wrap the program module declaration in nested namespaces. For
example:

    ```
    namespace Foo {
      namespace Bar {
        namespace Baz {
          // program module declaration
        }
      }
    }
    ```

-}
writeNestedParentNamespaces : List String -> List Writer -> Writer
writeNestedParentNamespaces parentModuleNames children =
    List.foldr
        (\parentModuleName child ->
            Writer.namespace
                { docs = Nothing, export = False, name = parentModuleName }
                [ child ]
        )
        (Writer.lines children)
        parentModuleNames
